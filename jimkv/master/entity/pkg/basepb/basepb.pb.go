// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: basepb/basepb.proto

package basepb

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type DataType int32

const (
	DataType_Invalid DataType = 0
	// 8 bit interger
	DataType_TinyInt DataType = 1
	// 16 bit interger
	DataType_SmallInt DataType = 2
	// 24 bit integer
	DataType_MediumInt DataType = 3
	// 32 bit interger
	DataType_Int DataType = 4
	// 64 bit interger
	DataType_BigInt DataType = 5
	DataType_Bit    DataType = 6
	// 32 bit float
	DataType_Float DataType = 10
	// 64 bit float
	DataType_Double    DataType = 11
	DataType_Decimal   DataType = 12
	DataType_Date      DataType = 20
	DataType_TimeStamp DataType = 21
	DataType_DateTime  DataType = 22
	DataType_Time      DataType = 23
	DataType_Year      DataType = 24
	// string UTF-8 max size 64 KB
	DataType_Varchar DataType = 30
	// Blob max size 64 KB
	DataType_Binary    DataType = 31
	DataType_Char      DataType = 32
	DataType_NChar     DataType = 33
	DataType_Text      DataType = 34
	DataType_VarBinary DataType = 35
	DataType_Json      DataType = 40
	DataType_Null      DataType = 50
)

var DataType_name = map[int32]string{
	0:  "Invalid",
	1:  "TinyInt",
	2:  "SmallInt",
	3:  "MediumInt",
	4:  "Int",
	5:  "BigInt",
	6:  "Bit",
	10: "Float",
	11: "Double",
	12: "Decimal",
	20: "Date",
	21: "TimeStamp",
	22: "DateTime",
	23: "Time",
	24: "Year",
	30: "Varchar",
	31: "Binary",
	32: "Char",
	33: "NChar",
	34: "Text",
	35: "VarBinary",
	40: "Json",
	50: "Null",
}

var DataType_value = map[string]int32{
	"Invalid":   0,
	"TinyInt":   1,
	"SmallInt":  2,
	"MediumInt": 3,
	"Int":       4,
	"BigInt":    5,
	"Bit":       6,
	"Float":     10,
	"Double":    11,
	"Decimal":   12,
	"Date":      20,
	"TimeStamp": 21,
	"DateTime":  22,
	"Time":      23,
	"Year":      24,
	"Varchar":   30,
	"Binary":    31,
	"Char":      32,
	"NChar":     33,
	"Text":      34,
	"VarBinary": 35,
	"Json":      40,
	"Null":      50,
}

func (x DataType) String() string {
	return proto.EnumName(DataType_name, int32(x))
}

func (DataType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{0}
}

type StoreType int32

const (
	StoreType_Store_Invalid StoreType = 0
	StoreType_Store_Hot     StoreType = 1
	StoreType_Store_Warm    StoreType = 2
	StoreType_Store_Mix     StoreType = 3
)

var StoreType_name = map[int32]string{
	0: "Store_Invalid",
	1: "Store_Hot",
	2: "Store_Warm",
	3: "Store_Mix",
}

var StoreType_value = map[string]int32{
	"Store_Invalid": 0,
	"Store_Hot":     1,
	"Store_Warm":    2,
	"Store_Mix":     3,
}

func (x StoreType) String() string {
	return proto.EnumName(StoreType_name, int32(x))
}

func (StoreType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{1}
}

type RangeType int32

const (
	RangeType_RNG_Invalid RangeType = 0
	RangeType_RNG_Index   RangeType = 1
	RangeType_RNG_Data    RangeType = 2
)

var RangeType_name = map[int32]string{
	0: "RNG_Invalid",
	1: "RNG_Index",
	2: "RNG_Data",
}

var RangeType_value = map[string]int32{
	"RNG_Invalid": 0,
	"RNG_Index":   1,
	"RNG_Data":    2,
}

func (x RangeType) String() string {
	return proto.EnumName(RangeType_name, int32(x))
}

func (RangeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{2}
}

// 1. Under any conditions, ms should initialize the new and old ds nodes into an Initial state after they are added to the cluster, except for the nodes that have been Logout.
// after ds self-inspection is completed, the data read-write service is officially launched via NodeLogin report
// Logout nodeï¼Œneed to Initial by person
type NodeState int32

const (
	NodeState_N_Invalid   NodeState = 0
	NodeState_N_Online    NodeState = 1
	NodeState_N_Offline   NodeState = 2
	NodeState_N_Updating  NodeState = 3
	NodeState_N_Offlining NodeState = 4
)

var NodeState_name = map[int32]string{
	0: "N_Invalid",
	1: "N_Online",
	2: "N_Offline",
	3: "N_Updating",
	4: "N_Offlining",
}

var NodeState_value = map[string]int32{
	"N_Invalid":   0,
	"N_Online":    1,
	"N_Offline":   2,
	"N_Updating":  3,
	"N_Offlining": 4,
}

func (x NodeState) String() string {
	return proto.EnumName(NodeState_name, int32(x))
}

func (NodeState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{3}
}

type RangePeerState int32

const (
	RangePeerState_RPS_Invalid  RangePeerState = 0
	RangePeerState_RPS_NoLeader RangePeerState = 1
	RangePeerState_RPS_Follower RangePeerState = 2
	RangePeerState_RPS_Leader   RangePeerState = 3
)

var RangePeerState_name = map[int32]string{
	0: "RPS_Invalid",
	1: "RPS_NoLeader",
	2: "RPS_Follower",
	3: "RPS_Leader",
}

var RangePeerState_value = map[string]int32{
	"RPS_Invalid":  0,
	"RPS_NoLeader": 1,
	"RPS_Follower": 2,
	"RPS_Leader":   3,
}

func (x RangePeerState) String() string {
	return proto.EnumName(RangePeerState_name, int32(x))
}

func (RangePeerState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{4}
}

type PeerType int32

const (
	PeerType_PeerType_Invalid PeerType = 0
	PeerType_PeerType_Normal  PeerType = 1
	PeerType_PeerType_Learner PeerType = 2
)

var PeerType_name = map[int32]string{
	0: "PeerType_Invalid",
	1: "PeerType_Normal",
	2: "PeerType_Learner",
}

var PeerType_value = map[string]int32{
	"PeerType_Invalid": 0,
	"PeerType_Normal":  1,
	"PeerType_Learner": 2,
}

func (x PeerType) String() string {
	return proto.EnumName(PeerType_name, int32(x))
}

func (PeerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{5}
}

type EventType int32

const (
	EventType_Event_Type_Invalid EventType = 0
	EventType_Event_Type_PUT     EventType = 1
	EventType_Event_Type_DELETE  EventType = 2
)

var EventType_name = map[int32]string{
	0: "Event_Type_Invalid",
	1: "Event_Type_PUT",
	2: "Event_Type_DELETE",
}

var EventType_value = map[string]int32{
	"Event_Type_Invalid": 0,
	"Event_Type_PUT":     1,
	"Event_Type_DELETE":  2,
}

func (x EventType) String() string {
	return proto.EnumName(EventType_name, int32(x))
}

func (EventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{6}
}

type WatcherType int32

const (
	WatcherType_Watcher_Type_Invalid  WatcherType = 0
	WatcherType_Watcher_Type_Node     WatcherType = 1
	WatcherType_Watcher_Type_Database WatcherType = 2
	WatcherType_Watcher_Type_Table    WatcherType = 3
	WatcherType_Watcher_Type_Range    WatcherType = 4
)

var WatcherType_name = map[int32]string{
	0: "Watcher_Type_Invalid",
	1: "Watcher_Type_Node",
	2: "Watcher_Type_Database",
	3: "Watcher_Type_Table",
	4: "Watcher_Type_Range",
}

var WatcherType_value = map[string]int32{
	"Watcher_Type_Invalid":  0,
	"Watcher_Type_Node":     1,
	"Watcher_Type_Database": 2,
	"Watcher_Type_Table":    3,
	"Watcher_Type_Range":    4,
}

func (x WatcherType) String() string {
	return proto.EnumName(WatcherType_name, int32(x))
}

func (WatcherType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{7}
}

type RangePeer struct {
	RangeId              uint64         `protobuf:"varint,1,opt,name=range_id,json=rangeId,proto3" json:"range_id,omitempty"`
	PeerId               uint64         `protobuf:"varint,2,opt,name=peer_id,json=peerId,proto3" json:"peer_id,omitempty"`
	State                RangePeerState `protobuf:"varint,3,opt,name=state,proto3,enum=basepb.RangePeerState" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *RangePeer) Reset()         { *m = RangePeer{} }
func (m *RangePeer) String() string { return proto.CompactTextString(m) }
func (*RangePeer) ProtoMessage()    {}
func (*RangePeer) Descriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{0}
}
func (m *RangePeer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangePeer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RangePeer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RangePeer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangePeer.Merge(m, src)
}
func (m *RangePeer) XXX_Size() int {
	return m.Size()
}
func (m *RangePeer) XXX_DiscardUnknown() {
	xxx_messageInfo_RangePeer.DiscardUnknown(m)
}

var xxx_messageInfo_RangePeer proto.InternalMessageInfo

func (m *RangePeer) GetRangeId() uint64 {
	if m != nil {
		return m.RangeId
	}
	return 0
}

func (m *RangePeer) GetPeerId() uint64 {
	if m != nil {
		return m.PeerId
	}
	return 0
}

func (m *RangePeer) GetState() RangePeerState {
	if m != nil {
		return m.State
	}
	return RangePeerState_RPS_Invalid
}

type Node struct {
	Id                   uint64       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Ip                   string       `protobuf:"bytes,2,opt,name=ip,proto3" json:"ip,omitempty"`
	ServerPort           uint32       `protobuf:"varint,3,opt,name=server_port,json=serverPort,proto3" json:"server_port,omitempty"`
	RaftPort             uint32       `protobuf:"varint,4,opt,name=raft_port,json=raftPort,proto3" json:"raft_port,omitempty"`
	AdminPort            uint32       `protobuf:"varint,5,opt,name=admin_port,json=adminPort,proto3" json:"admin_port,omitempty"`
	State                NodeState    `protobuf:"varint,6,opt,name=state,proto3,enum=basepb.NodeState" json:"state,omitempty"`
	Version              int64        `protobuf:"varint,7,opt,name=version,proto3" json:"version,omitempty"`
	RangePeers           []*RangePeer `protobuf:"bytes,8,rep,name=range_peers,json=rangePeers,proto3" json:"range_peers,omitempty"`
	LastUpdateTime       int64        `protobuf:"varint,9,opt,name=last_update_time,json=lastUpdateTime,proto3" json:"last_update_time,omitempty"`
	Type                 StoreType    `protobuf:"varint,10,opt,name=type,proto3,enum=basepb.StoreType" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{1}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(m, src)
}
func (m *Node) XXX_Size() int {
	return m.Size()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

func (m *Node) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Node) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *Node) GetServerPort() uint32 {
	if m != nil {
		return m.ServerPort
	}
	return 0
}

func (m *Node) GetRaftPort() uint32 {
	if m != nil {
		return m.RaftPort
	}
	return 0
}

func (m *Node) GetAdminPort() uint32 {
	if m != nil {
		return m.AdminPort
	}
	return 0
}

func (m *Node) GetState() NodeState {
	if m != nil {
		return m.State
	}
	return NodeState_N_Invalid
}

func (m *Node) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *Node) GetRangePeers() []*RangePeer {
	if m != nil {
		return m.RangePeers
	}
	return nil
}

func (m *Node) GetLastUpdateTime() int64 {
	if m != nil {
		return m.LastUpdateTime
	}
	return 0
}

func (m *Node) GetType() StoreType {
	if m != nil {
		return m.Type
	}
	return StoreType_Store_Invalid
}

type Peer struct {
	Id                   uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	NodeId               uint64   `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	Type                 PeerType `protobuf:"varint,3,opt,name=type,proto3,enum=basepb.PeerType" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Peer) Reset()         { *m = Peer{} }
func (m *Peer) String() string { return proto.CompactTextString(m) }
func (*Peer) ProtoMessage()    {}
func (*Peer) Descriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{2}
}
func (m *Peer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Peer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Peer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Peer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Peer.Merge(m, src)
}
func (m *Peer) XXX_Size() int {
	return m.Size()
}
func (m *Peer) XXX_DiscardUnknown() {
	xxx_messageInfo_Peer.DiscardUnknown(m)
}

var xxx_messageInfo_Peer proto.InternalMessageInfo

func (m *Peer) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Peer) GetNodeId() uint64 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *Peer) GetType() PeerType {
	if m != nil {
		return m.Type
	}
	return PeerType_PeerType_Invalid
}

type PeerStatus struct {
	Peer                 *Peer    `protobuf:"bytes,1,opt,name=peer,proto3" json:"peer,omitempty"`
	Index                uint64   `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	Commit               uint64   `protobuf:"varint,3,opt,name=commit,proto3" json:"commit,omitempty"`
	DownSeconds          uint64   `protobuf:"varint,4,opt,name=down_seconds,json=downSeconds,proto3" json:"down_seconds,omitempty"`
	Snapshotting         bool     `protobuf:"varint,5,opt,name=snapshotting,proto3" json:"snapshotting,omitempty"`
	Applied              uint64   `protobuf:"varint,6,opt,name=applied,proto3" json:"applied,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PeerStatus) Reset()         { *m = PeerStatus{} }
func (m *PeerStatus) String() string { return proto.CompactTextString(m) }
func (*PeerStatus) ProtoMessage()    {}
func (*PeerStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{3}
}
func (m *PeerStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PeerStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerStatus.Merge(m, src)
}
func (m *PeerStatus) XXX_Size() int {
	return m.Size()
}
func (m *PeerStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerStatus.DiscardUnknown(m)
}

var xxx_messageInfo_PeerStatus proto.InternalMessageInfo

func (m *PeerStatus) GetPeer() *Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *PeerStatus) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *PeerStatus) GetCommit() uint64 {
	if m != nil {
		return m.Commit
	}
	return 0
}

func (m *PeerStatus) GetDownSeconds() uint64 {
	if m != nil {
		return m.DownSeconds
	}
	return 0
}

func (m *PeerStatus) GetSnapshotting() bool {
	if m != nil {
		return m.Snapshotting
	}
	return false
}

func (m *PeerStatus) GetApplied() uint64 {
	if m != nil {
		return m.Applied
	}
	return 0
}

type Replica struct {
	RangeId              uint64   `protobuf:"varint,1,opt,name=range_id,json=rangeId,proto3" json:"range_id,omitempty"`
	Peer                 *Peer    `protobuf:"bytes,2,opt,name=peer,proto3" json:"peer,omitempty"`
	StartKey             []byte   `protobuf:"bytes,3,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey               []byte   `protobuf:"bytes,4,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Replica) Reset()         { *m = Replica{} }
func (m *Replica) String() string { return proto.CompactTextString(m) }
func (*Replica) ProtoMessage()    {}
func (*Replica) Descriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{4}
}
func (m *Replica) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Replica) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Replica.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Replica) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Replica.Merge(m, src)
}
func (m *Replica) XXX_Size() int {
	return m.Size()
}
func (m *Replica) XXX_DiscardUnknown() {
	xxx_messageInfo_Replica.DiscardUnknown(m)
}

var xxx_messageInfo_Replica proto.InternalMessageInfo

func (m *Replica) GetRangeId() uint64 {
	if m != nil {
		return m.RangeId
	}
	return 0
}

func (m *Replica) GetPeer() *Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *Replica) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *Replica) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

// RegionEpoch is from tidb, and is and is licensed under the Apache Public License v2.
// Source code can be found here: https://github.com/pingcap/pd
type RangeEpoch struct {
	// Conf change version, auto increment when add or remove peer
	ConfVer uint64 `protobuf:"varint,1,opt,name=conf_ver,json=confVer,proto3" json:"conf_ver,omitempty"`
	// Range version, auto increment when split or merge
	Version              uint64   `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RangeEpoch) Reset()         { *m = RangeEpoch{} }
func (m *RangeEpoch) String() string { return proto.CompactTextString(m) }
func (*RangeEpoch) ProtoMessage()    {}
func (*RangeEpoch) Descriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{5}
}
func (m *RangeEpoch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeEpoch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RangeEpoch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RangeEpoch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeEpoch.Merge(m, src)
}
func (m *RangeEpoch) XXX_Size() int {
	return m.Size()
}
func (m *RangeEpoch) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeEpoch.DiscardUnknown(m)
}

var xxx_messageInfo_RangeEpoch proto.InternalMessageInfo

func (m *RangeEpoch) GetConfVer() uint64 {
	if m != nil {
		return m.ConfVer
	}
	return 0
}

func (m *RangeEpoch) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

// indicate range key's structure
// describe how to interpret key bytes, used for dataserver to decode key
type KeySchema struct {
	// primarykey columns for data range, or index columns info for index range
	// order is sensitive for multi cols
	KeyCols []*KeySchema_ColumnInfo `protobuf:"bytes,1,rep,name=key_cols,json=keyCols,proto3" json:"key_cols,omitempty"`
	// only valid when range is a index range, to indicate whether index is unique or not
	UniqueIndex bool `protobuf:"varint,2,opt,name=unique_index,json=uniqueIndex,proto3" json:"unique_index,omitempty"`
	// only valid when range is a index range,
	// extra_cols are table's primary key, order is sensitive  for multi cols
	ExtraCols            []*KeySchema_ColumnInfo `protobuf:"bytes,3,rep,name=extra_cols,json=extraCols,proto3" json:"extra_cols,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *KeySchema) Reset()         { *m = KeySchema{} }
func (m *KeySchema) String() string { return proto.CompactTextString(m) }
func (*KeySchema) ProtoMessage()    {}
func (*KeySchema) Descriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{6}
}
func (m *KeySchema) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeySchema) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeySchema.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeySchema) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeySchema.Merge(m, src)
}
func (m *KeySchema) XXX_Size() int {
	return m.Size()
}
func (m *KeySchema) XXX_DiscardUnknown() {
	xxx_messageInfo_KeySchema.DiscardUnknown(m)
}

var xxx_messageInfo_KeySchema proto.InternalMessageInfo

func (m *KeySchema) GetKeyCols() []*KeySchema_ColumnInfo {
	if m != nil {
		return m.KeyCols
	}
	return nil
}

func (m *KeySchema) GetUniqueIndex() bool {
	if m != nil {
		return m.UniqueIndex
	}
	return false
}

func (m *KeySchema) GetExtraCols() []*KeySchema_ColumnInfo {
	if m != nil {
		return m.ExtraCols
	}
	return nil
}

type KeySchema_ColumnInfo struct {
	Id                   int32    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Type                 DataType `protobuf:"varint,2,opt,name=type,proto3,enum=basepb.DataType" json:"type,omitempty"`
	Unsigned             bool     `protobuf:"varint,3,opt,name=unsigned,proto3" json:"unsigned,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KeySchema_ColumnInfo) Reset()         { *m = KeySchema_ColumnInfo{} }
func (m *KeySchema_ColumnInfo) String() string { return proto.CompactTextString(m) }
func (*KeySchema_ColumnInfo) ProtoMessage()    {}
func (*KeySchema_ColumnInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{6, 0}
}
func (m *KeySchema_ColumnInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeySchema_ColumnInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeySchema_ColumnInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeySchema_ColumnInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeySchema_ColumnInfo.Merge(m, src)
}
func (m *KeySchema_ColumnInfo) XXX_Size() int {
	return m.Size()
}
func (m *KeySchema_ColumnInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_KeySchema_ColumnInfo.DiscardUnknown(m)
}

var xxx_messageInfo_KeySchema_ColumnInfo proto.InternalMessageInfo

func (m *KeySchema_ColumnInfo) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *KeySchema_ColumnInfo) GetType() DataType {
	if m != nil {
		return m.Type
	}
	return DataType_Invalid
}

func (m *KeySchema_ColumnInfo) GetUnsigned() bool {
	if m != nil {
		return m.Unsigned
	}
	return false
}

type Range struct {
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Range key range [start_key, end_key).
	// key by: prefix + table_id + real key
	StartKey   []byte      `protobuf:"bytes,2,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey     []byte      `protobuf:"bytes,3,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	RangeEpoch *RangeEpoch `protobuf:"bytes,4,opt,name=range_epoch,json=rangeEpoch,proto3" json:"range_epoch,omitempty"`
	//default first peer is leader
	Peers                []*Peer    `protobuf:"bytes,5,rep,name=peers,proto3" json:"peers,omitempty"`
	DbId                 int32      `protobuf:"varint,6,opt,name=db_id,json=dbId,proto3" json:"db_id,omitempty"`
	TableId              int32      `protobuf:"varint,7,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	KeySchema            *KeySchema `protobuf:"bytes,8,opt,name=key_schema,json=keySchema,proto3" json:"key_schema,omitempty"`
	Leader               uint64     `protobuf:"varint,9,opt,name=leader,proto3" json:"leader,omitempty"`
	RangeType            RangeType  `protobuf:"varint,10,opt,name=range_type,json=rangeType,proto3,enum=basepb.RangeType" json:"range_type,omitempty"`
	StoreType            StoreType  `protobuf:"varint,11,opt,name=store_type,json=storeType,proto3,enum=basepb.StoreType" json:"store_type,omitempty"`
	Term                 uint64     `protobuf:"varint,12,opt,name=term,proto3" json:"term,omitempty"`
	ParentRangeId        uint64     `protobuf:"varint,13,opt,name=parent_range_id,json=parentRangeId,proto3" json:"parent_range_id,omitempty"`
	IndexId              int32      `protobuf:"varint,14,opt,name=index_id,json=indexId,proto3" json:"index_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Range) Reset()         { *m = Range{} }
func (m *Range) String() string { return proto.CompactTextString(m) }
func (*Range) ProtoMessage()    {}
func (*Range) Descriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{7}
}
func (m *Range) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Range) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Range.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Range) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Range.Merge(m, src)
}
func (m *Range) XXX_Size() int {
	return m.Size()
}
func (m *Range) XXX_DiscardUnknown() {
	xxx_messageInfo_Range.DiscardUnknown(m)
}

var xxx_messageInfo_Range proto.InternalMessageInfo

func (m *Range) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Range) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *Range) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

func (m *Range) GetRangeEpoch() *RangeEpoch {
	if m != nil {
		return m.RangeEpoch
	}
	return nil
}

func (m *Range) GetPeers() []*Peer {
	if m != nil {
		return m.Peers
	}
	return nil
}

func (m *Range) GetDbId() int32 {
	if m != nil {
		return m.DbId
	}
	return 0
}

func (m *Range) GetTableId() int32 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *Range) GetKeySchema() *KeySchema {
	if m != nil {
		return m.KeySchema
	}
	return nil
}

func (m *Range) GetLeader() uint64 {
	if m != nil {
		return m.Leader
	}
	return 0
}

func (m *Range) GetRangeType() RangeType {
	if m != nil {
		return m.RangeType
	}
	return RangeType_RNG_Invalid
}

func (m *Range) GetStoreType() StoreType {
	if m != nil {
		return m.StoreType
	}
	return StoreType_Store_Invalid
}

func (m *Range) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *Range) GetParentRangeId() uint64 {
	if m != nil {
		return m.ParentRangeId
	}
	return 0
}

func (m *Range) GetIndexId() int32 {
	if m != nil {
		return m.IndexId
	}
	return 0
}

type Leader struct {
	RangeId              uint64   `protobuf:"varint,1,opt,name=range_id,json=rangeId,proto3" json:"range_id,omitempty"`
	NodeId               uint64   `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	NodeAddr             string   `protobuf:"bytes,3,opt,name=node_addr,json=nodeAddr,proto3" json:"node_addr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Leader) Reset()         { *m = Leader{} }
func (m *Leader) String() string { return proto.CompactTextString(m) }
func (*Leader) ProtoMessage()    {}
func (*Leader) Descriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{8}
}
func (m *Leader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Leader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Leader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Leader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Leader.Merge(m, src)
}
func (m *Leader) XXX_Size() int {
	return m.Size()
}
func (m *Leader) XXX_DiscardUnknown() {
	xxx_messageInfo_Leader.DiscardUnknown(m)
}

var xxx_messageInfo_Leader proto.InternalMessageInfo

func (m *Leader) GetRangeId() uint64 {
	if m != nil {
		return m.RangeId
	}
	return 0
}

func (m *Leader) GetNodeId() uint64 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *Leader) GetNodeAddr() string {
	if m != nil {
		return m.NodeAddr
	}
	return ""
}

//node event has nodeID
//db event has dbID
//table event has dbID,tableID
//range event has tableID, rangeID
type WatcherEvent struct {
	WatcherType          WatcherType `protobuf:"varint,1,opt,name=watcher_type,json=watcherType,proto3,enum=basepb.WatcherType" json:"watcher_type,omitempty"`
	EventType            EventType   `protobuf:"varint,2,opt,name=event_type,json=eventType,proto3,enum=basepb.EventType" json:"event_type,omitempty"`
	NodeId               uint64      `protobuf:"varint,3,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	DbId                 int32       `protobuf:"varint,4,opt,name=db_id,json=dbId,proto3" json:"db_id,omitempty"`
	TableId              int32       `protobuf:"varint,5,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	RangeId              uint64      `protobuf:"varint,6,opt,name=range_id,json=rangeId,proto3" json:"range_id,omitempty"`
	Value                []byte      `protobuf:"bytes,7,opt,name=value,proto3" json:"value,omitempty"`
	Version              uint64      `protobuf:"varint,8,opt,name=version,proto3" json:"version,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *WatcherEvent) Reset()         { *m = WatcherEvent{} }
func (m *WatcherEvent) String() string { return proto.CompactTextString(m) }
func (*WatcherEvent) ProtoMessage()    {}
func (*WatcherEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{9}
}
func (m *WatcherEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WatcherEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WatcherEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WatcherEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WatcherEvent.Merge(m, src)
}
func (m *WatcherEvent) XXX_Size() int {
	return m.Size()
}
func (m *WatcherEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_WatcherEvent.DiscardUnknown(m)
}

var xxx_messageInfo_WatcherEvent proto.InternalMessageInfo

func (m *WatcherEvent) GetWatcherType() WatcherType {
	if m != nil {
		return m.WatcherType
	}
	return WatcherType_Watcher_Type_Invalid
}

func (m *WatcherEvent) GetEventType() EventType {
	if m != nil {
		return m.EventType
	}
	return EventType_Event_Type_Invalid
}

func (m *WatcherEvent) GetNodeId() uint64 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *WatcherEvent) GetDbId() int32 {
	if m != nil {
		return m.DbId
	}
	return 0
}

func (m *WatcherEvent) GetTableId() int32 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *WatcherEvent) GetRangeId() uint64 {
	if m != nil {
		return m.RangeId
	}
	return 0
}

func (m *WatcherEvent) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *WatcherEvent) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func init() {
	proto.RegisterEnum("basepb.DataType", DataType_name, DataType_value)
	proto.RegisterEnum("basepb.StoreType", StoreType_name, StoreType_value)
	proto.RegisterEnum("basepb.RangeType", RangeType_name, RangeType_value)
	proto.RegisterEnum("basepb.NodeState", NodeState_name, NodeState_value)
	proto.RegisterEnum("basepb.RangePeerState", RangePeerState_name, RangePeerState_value)
	proto.RegisterEnum("basepb.PeerType", PeerType_name, PeerType_value)
	proto.RegisterEnum("basepb.EventType", EventType_name, EventType_value)
	proto.RegisterEnum("basepb.WatcherType", WatcherType_name, WatcherType_value)
	proto.RegisterType((*RangePeer)(nil), "basepb.RangePeer")
	proto.RegisterType((*Node)(nil), "basepb.Node")
	proto.RegisterType((*Peer)(nil), "basepb.Peer")
	proto.RegisterType((*PeerStatus)(nil), "basepb.PeerStatus")
	proto.RegisterType((*Replica)(nil), "basepb.Replica")
	proto.RegisterType((*RangeEpoch)(nil), "basepb.RangeEpoch")
	proto.RegisterType((*KeySchema)(nil), "basepb.KeySchema")
	proto.RegisterType((*KeySchema_ColumnInfo)(nil), "basepb.KeySchema.ColumnInfo")
	proto.RegisterType((*Range)(nil), "basepb.Range")
	proto.RegisterType((*Leader)(nil), "basepb.Leader")
	proto.RegisterType((*WatcherEvent)(nil), "basepb.WatcherEvent")
}

func init() { proto.RegisterFile("basepb/basepb.proto", fileDescriptor_722048aedd2e50a3) }

var fileDescriptor_722048aedd2e50a3 = []byte{
	// 1409 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x56, 0x4d, 0x6f, 0xdb, 0x46,
	0x13, 0x0e, 0x29, 0x4a, 0x22, 0x47, 0xb2, 0xb3, 0x5e, 0x7f, 0x44, 0x49, 0xde, 0xd7, 0x71, 0xf4,
	0x7e, 0xd4, 0x10, 0x5a, 0xa7, 0x70, 0x80, 0x16, 0x45, 0x4f, 0x49, 0xec, 0xb4, 0xaa, 0x1d, 0xc5,
	0xa0, 0xed, 0xa4, 0xb9, 0x94, 0x58, 0x89, 0x6b, 0x99, 0x30, 0x45, 0xb2, 0x4b, 0xca, 0xb6, 0x80,
	0x1e, 0x7b, 0x29, 0xd0, 0x1f, 0xd0, 0xfe, 0x98, 0xde, 0x0b, 0xf4, 0xd2, 0x7b, 0x2f, 0x45, 0xfa,
	0x47, 0x8a, 0x99, 0x25, 0x65, 0x32, 0x89, 0x83, 0x9e, 0x34, 0xcf, 0xcc, 0xf2, 0xd9, 0x99, 0x79,
	0x66, 0x57, 0x0b, 0xcb, 0x43, 0x91, 0xca, 0x64, 0xf8, 0x40, 0xff, 0x6c, 0x25, 0x2a, 0xce, 0x62,
	0xde, 0xd0, 0xe8, 0xce, 0x47, 0xe3, 0x20, 0x3b, 0x9d, 0x0e, 0xb7, 0x46, 0xf1, 0xe4, 0xc1, 0x38,
	0x1e, 0xc7, 0x0f, 0x28, 0x3c, 0x9c, 0x9e, 0x10, 0x22, 0x40, 0x96, 0xfe, 0xac, 0x3b, 0x01, 0xc7,
	0x15, 0xd1, 0x58, 0x1e, 0x48, 0xa9, 0xf8, 0x6d, 0xb0, 0x15, 0x02, 0x2f, 0xf0, 0x3b, 0xc6, 0x86,
	0xb1, 0x69, 0xb9, 0x4d, 0xc2, 0x7d, 0x9f, 0xdf, 0x82, 0x66, 0x22, 0xa5, 0xc2, 0x88, 0x49, 0x91,
	0x06, 0xc2, 0xbe, 0xcf, 0x3f, 0x84, 0x7a, 0x9a, 0x89, 0x4c, 0x76, 0x6a, 0x1b, 0xc6, 0xe6, 0xe2,
	0xf6, 0xda, 0x56, 0x9e, 0xd5, 0x9c, 0xf5, 0x10, 0xa3, 0xae, 0x5e, 0xd4, 0xfd, 0xcd, 0x04, 0x6b,
	0x10, 0xfb, 0x92, 0x2f, 0x82, 0x39, 0xdf, 0xc4, 0x0c, 0x7c, 0xc2, 0x09, 0x51, 0x3b, 0xae, 0x19,
	0x24, 0xfc, 0x1e, 0xb4, 0x52, 0xa9, 0xce, 0xa5, 0xf2, 0x92, 0x58, 0x65, 0x44, 0xbe, 0xe0, 0x82,
	0x76, 0x1d, 0xc4, 0x2a, 0xe3, 0x77, 0xc1, 0x51, 0xe2, 0x24, 0xd3, 0x61, 0x8b, 0xc2, 0x36, 0x3a,
	0x28, 0xf8, 0x6f, 0x00, 0xe1, 0x4f, 0x82, 0x48, 0x47, 0xeb, 0x14, 0x75, 0xc8, 0x43, 0xe1, 0x0f,
	0x8a, 0x9c, 0x1b, 0x94, 0xf3, 0x52, 0x91, 0x33, 0x66, 0x56, 0x4e, 0x97, 0x77, 0xa0, 0x79, 0x2e,
	0x55, 0x1a, 0xc4, 0x51, 0xa7, 0xb9, 0x61, 0x6c, 0xd6, 0xdc, 0x02, 0xf2, 0x6d, 0x68, 0xe9, 0x56,
	0x61, 0x1b, 0xd2, 0x8e, 0xbd, 0x51, 0xdb, 0x6c, 0x5d, 0x11, 0xcd, 0x8b, 0x77, 0x41, 0x15, 0x66,
	0xca, 0x37, 0x81, 0x85, 0x22, 0xcd, 0xbc, 0x69, 0xe2, 0x8b, 0x4c, 0x7a, 0x59, 0x30, 0x91, 0x1d,
	0x87, 0x68, 0x17, 0xd1, 0x7f, 0x4c, 0xee, 0xa3, 0x60, 0x22, 0xf9, 0xff, 0xc0, 0xca, 0x66, 0x89,
	0xec, 0x40, 0x35, 0xbf, 0xc3, 0x2c, 0x56, 0xf2, 0x68, 0x96, 0x48, 0x97, 0xc2, 0xdd, 0x63, 0xb0,
	0x48, 0xb7, 0x37, 0x9b, 0x79, 0x0b, 0x9a, 0x51, 0xec, 0xcb, 0x92, 0x58, 0x08, 0xfb, 0x3e, 0xff,
	0x6f, 0xce, 0xab, 0xb5, 0x62, 0x05, 0x2f, 0x92, 0x94, 0x68, 0x7f, 0x31, 0x00, 0x0a, 0xe5, 0xa6,
	0x29, 0xdf, 0x00, 0x0b, 0x8b, 0x24, 0xfe, 0xd6, 0x76, 0xbb, 0xfc, 0x91, 0x4b, 0x11, 0xbe, 0x02,
	0xf5, 0x20, 0xf2, 0xe5, 0x65, 0xbe, 0x9b, 0x06, 0x7c, 0x0d, 0x1a, 0xa3, 0x78, 0x32, 0x09, 0xb4,
	0x7a, 0x96, 0x9b, 0x23, 0x7e, 0x1f, 0xda, 0x7e, 0x7c, 0x11, 0x79, 0xa9, 0x1c, 0xc5, 0x91, 0x9f,
	0x92, 0x78, 0x96, 0xdb, 0x42, 0xdf, 0xa1, 0x76, 0xf1, 0x2e, 0xb4, 0xd3, 0x48, 0x24, 0xe9, 0x69,
	0x9c, 0x65, 0x41, 0x34, 0x26, 0x05, 0x6d, 0xb7, 0xe2, 0x43, 0x6d, 0x44, 0x92, 0x84, 0x81, 0xf4,
	0x49, 0x46, 0xcb, 0x2d, 0x60, 0xf7, 0x3b, 0x68, 0xba, 0x32, 0x09, 0x83, 0x91, 0x78, 0xdf, 0x44,
	0x17, 0x65, 0x99, 0xd7, 0x96, 0x75, 0x17, 0x9c, 0x34, 0x13, 0x2a, 0xf3, 0xce, 0xe4, 0x8c, 0x6a,
	0x68, 0xbb, 0x36, 0x39, 0xf6, 0xe4, 0x0c, 0x7b, 0x2c, 0x23, 0x9f, 0x42, 0x16, 0x85, 0x1a, 0x32,
	0xf2, 0xf7, 0xe4, 0xac, 0xfb, 0x08, 0x80, 0xe4, 0xdf, 0x4d, 0xe2, 0xd1, 0x29, 0x26, 0x30, 0x8a,
	0xa3, 0x13, 0xef, 0x3c, 0x6f, 0xa0, 0xe5, 0x36, 0x11, 0xbf, 0x90, 0xaa, 0x3c, 0x5c, 0xba, 0x6f,
	0x05, 0xec, 0x7e, 0x6f, 0x82, 0xb3, 0x27, 0x67, 0x87, 0xa3, 0x53, 0x39, 0x11, 0xfc, 0x53, 0xb0,
	0xcf, 0xe4, 0xcc, 0x1b, 0xc5, 0x61, 0xda, 0x31, 0x68, 0xce, 0xfe, 0x55, 0x24, 0x3b, 0x5f, 0xb4,
	0xf5, 0x24, 0x0e, 0xa7, 0x93, 0xa8, 0x1f, 0x9d, 0xc4, 0x6e, 0xf3, 0x4c, 0xce, 0x9e, 0xc4, 0x61,
	0x8a, 0x8d, 0x9e, 0x46, 0xc1, 0xb7, 0x53, 0xe9, 0x5d, 0xa9, 0x63, 0xbb, 0x2d, 0xed, 0xeb, 0x93,
	0x46, 0x9f, 0x03, 0xc8, 0xcb, 0x4c, 0x09, 0xcd, 0x5e, 0xfb, 0x07, 0xec, 0x0e, 0xad, 0x47, 0xfe,
	0x3b, 0xdf, 0x00, 0x5c, 0x05, 0x4a, 0x43, 0x58, 0xa7, 0x21, 0x2c, 0x66, 0xcd, 0xac, 0xce, 0xda,
	0x8e, 0xc8, 0xc4, 0xd5, 0xac, 0xf1, 0x3b, 0x60, 0x4f, 0xa3, 0x34, 0x18, 0x47, 0xd2, 0xa7, 0x16,
	0xdb, 0xee, 0x1c, 0x77, 0xff, 0xa8, 0x41, 0x9d, 0x5a, 0xf9, 0xd6, 0x80, 0x57, 0x94, 0x31, 0xaf,
	0x57, 0xa6, 0x56, 0x56, 0x86, 0x3f, 0x2c, 0xce, 0xac, 0x44, 0x69, 0x48, 0xb6, 0xd6, 0x36, 0xaf,
	0x9c, 0x59, 0x12, 0x2d, 0x3f, 0xb4, 0x5a, 0xc0, 0x2e, 0xd4, 0xf5, 0x11, 0xaf, 0x53, 0x73, 0xaa,
	0x73, 0xa2, 0x43, 0x7c, 0x19, 0xea, 0xfe, 0x10, 0x47, 0xac, 0x41, 0xd5, 0x5b, 0xfe, 0xb0, 0xef,
	0xa3, 0xf2, 0x99, 0x18, 0x86, 0x34, 0x7a, 0x4d, 0xf2, 0x37, 0x09, 0xf7, 0x7d, 0xfe, 0x31, 0x00,
	0x2a, 0x9a, 0x52, 0x73, 0x3b, 0x36, 0xe5, 0xb1, 0xf4, 0x56, 0xd7, 0x5d, 0xe7, 0x6c, 0x3e, 0x03,
	0x6b, 0xd0, 0x08, 0xa5, 0xf0, 0xa5, 0xa2, 0x0b, 0xc3, 0x72, 0x73, 0x84, 0x4c, 0xba, 0xa4, 0x77,
	0x5d, 0x17, 0x54, 0x11, 0xf5, 0xda, 0x51, 0x85, 0x89, 0x5f, 0xa4, 0x78, 0x8d, 0xe8, 0x2f, 0x5a,
	0xd7, 0x5d, 0x30, 0x4e, 0x5a, 0x98, 0x9c, 0x83, 0x95, 0x49, 0x35, 0xe9, 0xb4, 0x69, 0x67, 0xb2,
	0xf9, 0xff, 0xe1, 0x66, 0x22, 0x94, 0x8c, 0x32, 0x6f, 0x7e, 0xbc, 0x16, 0x28, 0xbc, 0xa0, 0xdd,
	0x6e, 0x7e, 0xc8, 0x6e, 0x83, 0x4d, 0xb3, 0x87, 0x0b, 0x16, 0x75, 0x13, 0x08, 0xf7, 0xfd, 0xee,
	0x2b, 0x68, 0xec, 0xeb, 0x22, 0xde, 0xff, 0xb7, 0xf3, 0xee, 0x9b, 0xec, 0x2e, 0x38, 0x14, 0x10,
	0xbe, 0xaf, 0x48, 0x66, 0xc7, 0xb5, 0xd1, 0xf1, 0xc8, 0xf7, 0x55, 0xf7, 0x47, 0x13, 0xda, 0x2f,
	0x45, 0x36, 0x3a, 0x95, 0x6a, 0xf7, 0x5c, 0x46, 0x19, 0xff, 0x04, 0xda, 0x17, 0x1a, 0xeb, 0xb2,
	0x0d, 0x2a, 0x7b, 0xb9, 0x28, 0x3b, 0x5f, 0x4b, 0x85, 0xb7, 0x2e, 0xae, 0x00, 0x36, 0x4b, 0x22,
	0x81, 0x57, 0x9a, 0xe4, 0x79, 0xb3, 0x88, 0x5a, 0x37, 0x4b, 0x16, 0x66, 0x39, 0xe1, 0x5a, 0x25,
	0xe1, 0xf9, 0x8c, 0x58, 0xd7, 0xcc, 0x48, 0xbd, 0x3a, 0x23, 0xe5, 0xa6, 0x34, 0xaa, 0x4d, 0x59,
	0x81, 0xfa, 0xb9, 0x08, 0xa7, 0x92, 0xc6, 0xaa, 0xed, 0x6a, 0x50, 0xbe, 0x4e, 0xec, 0xca, 0x75,
	0xd2, 0xfb, 0xd9, 0x04, 0xbb, 0x38, 0x76, 0xbc, 0x05, 0xcd, 0x7e, 0x74, 0x2e, 0xc2, 0xc0, 0x67,
	0x37, 0x10, 0x1c, 0x05, 0xd1, 0xac, 0x1f, 0x65, 0xcc, 0xe0, 0x6d, 0xb0, 0x0f, 0x27, 0x22, 0x0c,
	0x11, 0x99, 0x7c, 0x01, 0x9c, 0x67, 0xd2, 0x0f, 0xa6, 0x13, 0x84, 0x35, 0xde, 0x84, 0x1a, 0x1a,
	0x16, 0x07, 0x68, 0x3c, 0x0e, 0xc6, 0x68, 0xd7, 0xd1, 0xf9, 0x38, 0xc8, 0x58, 0x83, 0x3b, 0x50,
	0x7f, 0x1a, 0xc6, 0x22, 0x63, 0x80, 0xf1, 0x9d, 0x78, 0x3a, 0x0c, 0x25, 0x6b, 0x21, 0xfd, 0x8e,
	0x1c, 0x05, 0x13, 0x11, 0xb2, 0x36, 0xb7, 0xc1, 0xda, 0x11, 0x99, 0x64, 0x2b, 0x48, 0x8d, 0xff,
	0x72, 0x87, 0x99, 0x98, 0x24, 0x6c, 0x15, 0xf7, 0xdd, 0xc9, 0xff, 0xf8, 0xd8, 0x1a, 0x2e, 0x23,
	0xeb, 0x16, 0x5a, 0xaf, 0xa4, 0x50, 0xac, 0x83, 0x3c, 0x2f, 0x84, 0x1a, 0x9d, 0x0a, 0xc5, 0xd6,
	0x75, 0x02, 0x91, 0x50, 0x33, 0x76, 0x0f, 0x97, 0x3c, 0x41, 0xef, 0x06, 0x66, 0x30, 0x20, 0xf3,
	0x3e, 0x31, 0xc8, 0xcb, 0x8c, 0x75, 0x71, 0xa3, 0x17, 0x42, 0xe5, 0xab, 0xff, 0x83, 0x81, 0xaf,
	0xd2, 0x38, 0x62, 0x9b, 0x68, 0x0d, 0xa6, 0x61, 0xc8, 0xb6, 0x7b, 0xfb, 0xe0, 0xcc, 0x87, 0x9e,
	0x2f, 0xc1, 0x02, 0x01, 0xef, 0xaa, 0x43, 0x0b, 0x79, 0xdc, 0xfb, 0x32, 0xc6, 0x1e, 0x2d, 0x02,
	0x68, 0xf8, 0x52, 0xa8, 0x89, 0xee, 0x92, 0xc6, 0xcf, 0x82, 0x4b, 0x56, 0xeb, 0x7d, 0x96, 0xbf,
	0xa6, 0x88, 0xed, 0x26, 0xb4, 0xdc, 0xc1, 0x17, 0x55, 0x2e, 0xed, 0xf0, 0xe5, 0xa5, 0xee, 0x37,
	0x42, 0x54, 0x86, 0x99, 0xbd, 0xaf, 0xc1, 0x99, 0x3f, 0x3f, 0x70, 0xe5, 0xa0, 0xf4, 0x61, 0x1b,
	0xec, 0x81, 0xf7, 0x3c, 0x0a, 0x83, 0x48, 0x32, 0x43, 0x07, 0x9f, 0x9f, 0x9c, 0x10, 0x34, 0x31,
	0xa5, 0x81, 0x47, 0x6f, 0x87, 0x20, 0x1a, 0xb3, 0x1a, 0x6e, 0x5b, 0x84, 0xd1, 0x61, 0xf5, 0x8e,
	0x61, 0xb1, 0xfa, 0x18, 0xa3, 0xcc, 0x0e, 0x0e, 0x4b, 0x1b, 0x30, 0x68, 0xa3, 0x63, 0x10, 0xeb,
	0x13, 0xc9, 0x8c, 0xc2, 0xf3, 0x34, 0x0e, 0xc3, 0xf8, 0x42, 0x2a, 0xbd, 0x0f, 0x7a, 0xf2, 0x15,
	0xb5, 0xde, 0x1e, 0xd8, 0xc5, 0xbb, 0x81, 0xaf, 0x00, 0x2b, 0xec, 0x12, 0xeb, 0x32, 0xdc, 0x9c,
	0x7b, 0x07, 0xb1, 0xc2, 0x31, 0x30, 0x2a, 0x4b, 0xf7, 0xa5, 0x50, 0x11, 0x92, 0xf7, 0x06, 0xe0,
	0xcc, 0x8f, 0x13, 0x5f, 0x03, 0x4e, 0xc0, 0x7b, 0x83, 0x8f, 0xc3, 0x62, 0xc9, 0x7f, 0x70, 0x7c,
	0xc4, 0x0c, 0xbe, 0x0a, 0x4b, 0x25, 0xdf, 0xce, 0xee, 0xfe, 0xee, 0xd1, 0x2e, 0x33, 0x7b, 0x3f,
	0x18, 0xd0, 0x2a, 0x9d, 0x6a, 0xde, 0x81, 0x95, 0x1c, 0xbe, 0x49, 0xba, 0x0a, 0x4b, 0x95, 0x08,
	0x8a, 0xc0, 0x0c, 0x7e, 0x1b, 0x56, 0x2b, 0x6e, 0x54, 0x09, 0xcf, 0x3d, 0x33, 0x31, 0xbd, 0x4a,
	0xe8, 0x08, 0x4f, 0x2c, 0xab, 0xbd, 0xe5, 0xa7, 0xa6, 0x33, 0xeb, 0x31, 0xfb, 0xf5, 0xf5, 0xba,
	0xf1, 0xfb, 0xeb, 0x75, 0xe3, 0xcf, 0xd7, 0xeb, 0xc6, 0x4f, 0x7f, 0xad, 0xdf, 0x18, 0x36, 0xe8,
	0xed, 0xfd, 0xf0, 0xef, 0x00, 0x00, 0x00, 0xff, 0xff, 0x25, 0x2b, 0x59, 0x61, 0xc9, 0x0b, 0x00,
	0x00,
}

func (m *RangePeer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangePeer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangePeer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.State != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x18
	}
	if m.PeerId != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.PeerId))
		i--
		dAtA[i] = 0x10
	}
	if m.RangeId != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.RangeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Type != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x50
	}
	if m.LastUpdateTime != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.LastUpdateTime))
		i--
		dAtA[i] = 0x48
	}
	if len(m.RangePeers) > 0 {
		for iNdEx := len(m.RangePeers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RangePeers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBasepb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.Version != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x38
	}
	if m.State != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x30
	}
	if m.AdminPort != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.AdminPort))
		i--
		dAtA[i] = 0x28
	}
	if m.RaftPort != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.RaftPort))
		i--
		dAtA[i] = 0x20
	}
	if m.ServerPort != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.ServerPort))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Ip) > 0 {
		i -= len(m.Ip)
		copy(dAtA[i:], m.Ip)
		i = encodeVarintBasepb(dAtA, i, uint64(len(m.Ip)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Peer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Peer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Peer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Type != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if m.NodeId != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.NodeId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PeerStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PeerStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Applied != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.Applied))
		i--
		dAtA[i] = 0x30
	}
	if m.Snapshotting {
		i--
		if m.Snapshotting {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.DownSeconds != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.DownSeconds))
		i--
		dAtA[i] = 0x20
	}
	if m.Commit != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.Commit))
		i--
		dAtA[i] = 0x18
	}
	if m.Index != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	if m.Peer != nil {
		{
			size, err := m.Peer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBasepb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Replica) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Replica) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Replica) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintBasepb(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintBasepb(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Peer != nil {
		{
			size, err := m.Peer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBasepb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.RangeId != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.RangeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RangeEpoch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeEpoch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeEpoch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Version != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x10
	}
	if m.ConfVer != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.ConfVer))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *KeySchema) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeySchema) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeySchema) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ExtraCols) > 0 {
		for iNdEx := len(m.ExtraCols) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExtraCols[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBasepb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.UniqueIndex {
		i--
		if m.UniqueIndex {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.KeyCols) > 0 {
		for iNdEx := len(m.KeyCols) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.KeyCols[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBasepb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *KeySchema_ColumnInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeySchema_ColumnInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeySchema_ColumnInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Unsigned {
		i--
		if m.Unsigned {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Range) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Range) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Range) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IndexId != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.IndexId))
		i--
		dAtA[i] = 0x70
	}
	if m.ParentRangeId != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.ParentRangeId))
		i--
		dAtA[i] = 0x68
	}
	if m.Term != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x60
	}
	if m.StoreType != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.StoreType))
		i--
		dAtA[i] = 0x58
	}
	if m.RangeType != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.RangeType))
		i--
		dAtA[i] = 0x50
	}
	if m.Leader != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.Leader))
		i--
		dAtA[i] = 0x48
	}
	if m.KeySchema != nil {
		{
			size, err := m.KeySchema.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBasepb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.TableId != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x38
	}
	if m.DbId != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.DbId))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Peers) > 0 {
		for iNdEx := len(m.Peers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Peers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBasepb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.RangeEpoch != nil {
		{
			size, err := m.RangeEpoch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBasepb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintBasepb(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintBasepb(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Leader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Leader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Leader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NodeAddr) > 0 {
		i -= len(m.NodeAddr)
		copy(dAtA[i:], m.NodeAddr)
		i = encodeVarintBasepb(dAtA, i, uint64(len(m.NodeAddr)))
		i--
		dAtA[i] = 0x1a
	}
	if m.NodeId != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.NodeId))
		i--
		dAtA[i] = 0x10
	}
	if m.RangeId != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.RangeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WatcherEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WatcherEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WatcherEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Version != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintBasepb(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x3a
	}
	if m.RangeId != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.RangeId))
		i--
		dAtA[i] = 0x30
	}
	if m.TableId != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x28
	}
	if m.DbId != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.DbId))
		i--
		dAtA[i] = 0x20
	}
	if m.NodeId != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.NodeId))
		i--
		dAtA[i] = 0x18
	}
	if m.EventType != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.EventType))
		i--
		dAtA[i] = 0x10
	}
	if m.WatcherType != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.WatcherType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintBasepb(dAtA []byte, offset int, v uint64) int {
	offset -= sovBasepb(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RangePeer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeId != 0 {
		n += 1 + sovBasepb(uint64(m.RangeId))
	}
	if m.PeerId != 0 {
		n += 1 + sovBasepb(uint64(m.PeerId))
	}
	if m.State != 0 {
		n += 1 + sovBasepb(uint64(m.State))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovBasepb(uint64(m.Id))
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovBasepb(uint64(l))
	}
	if m.ServerPort != 0 {
		n += 1 + sovBasepb(uint64(m.ServerPort))
	}
	if m.RaftPort != 0 {
		n += 1 + sovBasepb(uint64(m.RaftPort))
	}
	if m.AdminPort != 0 {
		n += 1 + sovBasepb(uint64(m.AdminPort))
	}
	if m.State != 0 {
		n += 1 + sovBasepb(uint64(m.State))
	}
	if m.Version != 0 {
		n += 1 + sovBasepb(uint64(m.Version))
	}
	if len(m.RangePeers) > 0 {
		for _, e := range m.RangePeers {
			l = e.Size()
			n += 1 + l + sovBasepb(uint64(l))
		}
	}
	if m.LastUpdateTime != 0 {
		n += 1 + sovBasepb(uint64(m.LastUpdateTime))
	}
	if m.Type != 0 {
		n += 1 + sovBasepb(uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Peer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovBasepb(uint64(m.Id))
	}
	if m.NodeId != 0 {
		n += 1 + sovBasepb(uint64(m.NodeId))
	}
	if m.Type != 0 {
		n += 1 + sovBasepb(uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PeerStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovBasepb(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovBasepb(uint64(m.Index))
	}
	if m.Commit != 0 {
		n += 1 + sovBasepb(uint64(m.Commit))
	}
	if m.DownSeconds != 0 {
		n += 1 + sovBasepb(uint64(m.DownSeconds))
	}
	if m.Snapshotting {
		n += 2
	}
	if m.Applied != 0 {
		n += 1 + sovBasepb(uint64(m.Applied))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Replica) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeId != 0 {
		n += 1 + sovBasepb(uint64(m.RangeId))
	}
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovBasepb(uint64(l))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovBasepb(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovBasepb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RangeEpoch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConfVer != 0 {
		n += 1 + sovBasepb(uint64(m.ConfVer))
	}
	if m.Version != 0 {
		n += 1 + sovBasepb(uint64(m.Version))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KeySchema) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.KeyCols) > 0 {
		for _, e := range m.KeyCols {
			l = e.Size()
			n += 1 + l + sovBasepb(uint64(l))
		}
	}
	if m.UniqueIndex {
		n += 2
	}
	if len(m.ExtraCols) > 0 {
		for _, e := range m.ExtraCols {
			l = e.Size()
			n += 1 + l + sovBasepb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KeySchema_ColumnInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovBasepb(uint64(m.Id))
	}
	if m.Type != 0 {
		n += 1 + sovBasepb(uint64(m.Type))
	}
	if m.Unsigned {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Range) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovBasepb(uint64(m.Id))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovBasepb(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovBasepb(uint64(l))
	}
	if m.RangeEpoch != nil {
		l = m.RangeEpoch.Size()
		n += 1 + l + sovBasepb(uint64(l))
	}
	if len(m.Peers) > 0 {
		for _, e := range m.Peers {
			l = e.Size()
			n += 1 + l + sovBasepb(uint64(l))
		}
	}
	if m.DbId != 0 {
		n += 1 + sovBasepb(uint64(m.DbId))
	}
	if m.TableId != 0 {
		n += 1 + sovBasepb(uint64(m.TableId))
	}
	if m.KeySchema != nil {
		l = m.KeySchema.Size()
		n += 1 + l + sovBasepb(uint64(l))
	}
	if m.Leader != 0 {
		n += 1 + sovBasepb(uint64(m.Leader))
	}
	if m.RangeType != 0 {
		n += 1 + sovBasepb(uint64(m.RangeType))
	}
	if m.StoreType != 0 {
		n += 1 + sovBasepb(uint64(m.StoreType))
	}
	if m.Term != 0 {
		n += 1 + sovBasepb(uint64(m.Term))
	}
	if m.ParentRangeId != 0 {
		n += 1 + sovBasepb(uint64(m.ParentRangeId))
	}
	if m.IndexId != 0 {
		n += 1 + sovBasepb(uint64(m.IndexId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Leader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeId != 0 {
		n += 1 + sovBasepb(uint64(m.RangeId))
	}
	if m.NodeId != 0 {
		n += 1 + sovBasepb(uint64(m.NodeId))
	}
	l = len(m.NodeAddr)
	if l > 0 {
		n += 1 + l + sovBasepb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WatcherEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WatcherType != 0 {
		n += 1 + sovBasepb(uint64(m.WatcherType))
	}
	if m.EventType != 0 {
		n += 1 + sovBasepb(uint64(m.EventType))
	}
	if m.NodeId != 0 {
		n += 1 + sovBasepb(uint64(m.NodeId))
	}
	if m.DbId != 0 {
		n += 1 + sovBasepb(uint64(m.DbId))
	}
	if m.TableId != 0 {
		n += 1 + sovBasepb(uint64(m.TableId))
	}
	if m.RangeId != 0 {
		n += 1 + sovBasepb(uint64(m.RangeId))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovBasepb(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovBasepb(uint64(m.Version))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovBasepb(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBasepb(x uint64) (n int) {
	return sovBasepb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RangePeer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBasepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangePeer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangePeer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeId", wireType)
			}
			m.RangeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			m.PeerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= RangePeerState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBasepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBasepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerPort", wireType)
			}
			m.ServerPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftPort", wireType)
			}
			m.RaftPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RaftPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminPort", wireType)
			}
			m.AdminPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdminPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= NodeState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangePeers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RangePeers = append(m.RangePeers, &RangePeer{})
			if err := m.RangePeers[len(m.RangePeers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdateTime", wireType)
			}
			m.LastUpdateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUpdateTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= StoreType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBasepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Peer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBasepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Peer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Peer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= PeerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBasepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBasepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &Peer{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			m.Commit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Commit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownSeconds", wireType)
			}
			m.DownSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DownSeconds |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snapshotting", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Snapshotting = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Applied", wireType)
			}
			m.Applied = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Applied |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBasepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Replica) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBasepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Replica: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Replica: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeId", wireType)
			}
			m.RangeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &Peer{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBasepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeEpoch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBasepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeEpoch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeEpoch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfVer", wireType)
			}
			m.ConfVer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfVer |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBasepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeySchema) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBasepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeySchema: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeySchema: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyCols", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyCols = append(m.KeyCols, &KeySchema_ColumnInfo{})
			if err := m.KeyCols[len(m.KeyCols)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueIndex", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UniqueIndex = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraCols", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtraCols = append(m.ExtraCols, &KeySchema_ColumnInfo{})
			if err := m.ExtraCols[len(m.ExtraCols)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBasepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeySchema_ColumnInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBasepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= DataType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unsigned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Unsigned = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBasepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Range) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBasepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Range: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Range: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeEpoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RangeEpoch == nil {
				m.RangeEpoch = &RangeEpoch{}
			}
			if err := m.RangeEpoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Peers = append(m.Peers, &Peer{})
			if err := m.Peers[len(m.Peers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbId", wireType)
			}
			m.DbId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DbId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeySchema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeySchema == nil {
				m.KeySchema = &KeySchema{}
			}
			if err := m.KeySchema.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			m.Leader = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Leader |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeType", wireType)
			}
			m.RangeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeType |= RangeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreType", wireType)
			}
			m.StoreType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreType |= StoreType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentRangeId", wireType)
			}
			m.ParentRangeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentRangeId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			m.IndexId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBasepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Leader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBasepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Leader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Leader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeId", wireType)
			}
			m.RangeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBasepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WatcherEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBasepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WatcherEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WatcherEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WatcherType", wireType)
			}
			m.WatcherType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WatcherType |= WatcherType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= EventType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbId", wireType)
			}
			m.DbId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DbId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeId", wireType)
			}
			m.RangeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBasepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBasepb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBasepb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBasepb
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBasepb
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBasepb
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBasepb        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBasepb          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBasepb = fmt.Errorf("proto: unexpected end of group")
)
